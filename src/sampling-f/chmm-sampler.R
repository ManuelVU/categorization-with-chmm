################################################################################
# Sampler for the Coupled Hidden Markov model
# The function returns a list that includes the posterior samples of the model
# parameters, the acceptance probability and the step size of the HMC algorithm 
# for each participant independently.
################################################################################

# The function takes 10 arguments
#   1:  data_chmm, data file in the CHMM format as generated by the function
#       transform_data_chmm() in the ~/sampling-f/ directory.
#   2:  metric, the dissimilarity metric to be used by the model. The default is 
#       currently set to distinctive which is the function introduced by Lee and
#       Navarro (2002) equation 12.
#   3:  order_p, order used by the Minkowski distance metric. This parameter is 
#       currently set to 1 as the Minkowski metric has not been implemented.
#   4:  n_iterations, number of iterations to sample.
#   5:  n_burn, number of iterations to discard.
#   6:  n_cores, number of cores to be used during parallel computing.
#   7:  parameters_initial_values, list containing the initial values of the 
#       model's parameters for each participant, the names of the parameters 
#       should be "alpha", "beta", "gamma", "epsilon". The initial values of the 
#       hidden states are generated internally by the function.
#   8:  start_setp_size, starting value for the step size used by the HMC 
#       algorithm,
#   9:  hmc_acceptance, target acceptance probability for the HMC algorithm.
#   10: prior_parameters, values of the parameters of the prior distributions 
#       of the model parameters. The prior distributions are set as:
#         alpha   ~ gamma(shape, rate)
#         beta    ~ gamma(shape, rate)
#         gamma   ~ beta(shape1, shape2)
#         epsilon ~ beta(shape1, shape2)

chmm_sampling <- function(data_chmm, metric = "distinctive", order_p = 1, 
                          n_iterations, n_burn, n_cores,
                          parameters_initial_values,
                          start_step_size, hmc_acceptance, 
                          prior_parameters) {
  
  # Load library for parallel computing and register cores
  library(doParallel)
  library(foreach)
  if(n_cores > parallel::detectCores()){
    message("Number of cores selected is greater than available number.")
    
    message(paste(c("Setting number of cores to: ", parallel::detectCores()),
                  collapse = ""))
    
    n_cores <- parallel::detectCores()
  }
  
  doParallel::registerDoParallel(n_cores)
  
  # Separate data
  responses <- data_chmm$response
  trials_participant <- data_chmm$participant_t
  features <- data_chmm$stimulus_features
  participants <- dim(responses)[3]
  stimulus <- dim(responses)[1]
  
  # Obtain similarity matrix from stimulus features
  if (metric == "distinctive") {
    stimulus_distinctive <- distinctive_ln(stimulus_features = features)
    stimulus_distance <- featural_distance(distinctive_features = 
                                             stimulus_distinctive)    
  } else if (metric == "minkowski") {
    stimulus_distance <- minkowski_distance(stimulus_features = features,
                                            p = order_p)
  }
  
  stimulus_similarity <- similarity_ij(decay_rate = 1, decay_function = 1, 
                                       dissimilarity = stimulus_distance)
  
  # Start sample matrix for individual model parameters and add initial value 
  # to row one
  sample_gamma <- matrix(data = parameters_initial_values$gamma,
                         byrow = TRUE, 
                         ncol = participants, 
                         nrow = n_iterations)
  sample_epsilon <- matrix(data = parameters_initial_values$epsilon, 
                           byrow = TRUE, 
                           ncol = participants, 
                           nrow = n_iterations)
  sample_alpha <- matrix(data = parameters_initial_values$alpha, 
                         byrow = TRUE, 
                         ncol = participants, 
                         nrow = n_iterations)
  sample_beta <- matrix(data = parameters_initial_values$beta, 
                        byrow = TRUE, 
                        ncol = participants, 
                        nrow = n_iterations)
  
  # Add initial sample of states to initial values
  parameters_initial_values$states <- initial_states(
    n_chains = stimulus, 
    n_trials = trials_participant,
    n_participants = participants, 
    similarity = stimulus_similarity,
    initial_state_probability = sample_gamma[1,],
    inertia_category_a = sample_alpha[1,],
    inertia_category_b = sample_beta[1,])
  
  # Start states array to store samples of states
  sample_states <- array(data = NA, dim = c(dim(responses), n_iterations))
  
  # Initialize states at their initial values
  sample_states[, , , 1] <- parameters_initial_values$states
  
  # Initialize step size and number of steps for HMC
  step_size <- start_step_size
  n_leaps <- 30
  acc <- matrix(data = NA, nrow = participants, ncol = 100)
  acc[,1] <- rep(x = 1, times = participants)
  
  # Start counter for acceptance rate
  count <- 1
  
  # Start progress bar
  progress <- txtProgressBar(min = 1, max = n_iterations, style = 3, 
                             width = 50, char = "=")
  
  # Start sampler
  for (sample in 2:n_iterations) {
    
    # Add to count position
    count <- count + 1
    
    # Update participants states in parallel
    st <- foreach(pp = 1:participants) %dopar% {
      forward_backward_all(states_current =
                             sample_states[, 1:trials_participant[pp], pp,
                                           (sample - 1)],
                           responses = responses[, 1:trials_participant[pp], pp],
                           similarity = stimulus_similarity,
                           n_states = 2,
                           total_trials = trials_participant[pp],
                           total_chains = stimulus,
                           epsilon = sample_epsilon[(sample - 1), pp],
                           gamma = sample_gamma[(sample - 1), pp],
                           alpha = sample_alpha[(sample - 1), pp],
                           beta = sample_beta[(sample - 1), pp])
    }
    
    # Move current updated state values to sample array
    for (pp in 1:participants) {
      sample_states[, 1:trials_participant[pp], pp, sample] <- st[[pp]]
    }
    
    # Use Hamiltonian MC to update participant's alpha and beta in parallel
    hm <- foreach(pp = 1:participants) %dopar% {
      hamiltonian_mc(states = sample_states[, 1:trials_participant[pp], pp, 
                                            sample],
                     alpha_tilde = log(sample_alpha[(sample - 1), pp]),
                     beta_tilde = log(sample_beta[(sample - 1), pp]),
                     alpha_prior = c(prior_parameters$alpha[1], 
                                     prior_parameters$alpha[2]), 
                     beta_prior = c(prior_parameters$beta[1],
                                    prior_parameters$beta[2]),
                     similarity = stimulus_similarity,
                     leap = n_leaps, 
                     leap_size = step_size[pp])
    }
    
    
    # Transform and update participants alpha and beta
    for (pp in 1:participants) {
      sample_alpha[sample, pp] <- exp(hm[[pp]][[1]][1])
      sample_beta[sample, pp] <- exp(hm[[pp]][[1]][2])
      if (sample <= n_burn){
        acc[pp, count] <- hm[[pp]][[2]]  
      }
    }
    
    # Update gamma parameter
    sample_gamma[sample, ] <- gamma_update(
      initial_states = sample_states[, 1, , sample],
      gamma_prior = c(prior_parameters$gamma[1],
                      prior_parameters$gamma[2]))
    
    # Update epsilon parameter
    sample_epsilon[sample, ] <- epsilon_update(
      states_all = sample_states[, , , sample],
      responses_all = responses,
      epsilon_prior = c(prior_parameters$epsilon[1],
                        prior_parameters$epsilon[2]))
    
    # Update step size during burn in for Hamiltonian
    if ((sample %% 100) == 0 & (sample <= n_burn)) {
      step_size <- adjust_step(step_size = step_size, 
                               acceptance_prob = 
                                 rowMeans(x = acc, na.rm = TRUE),
                               target_acceptance = hmc_acceptance)
      count <- 0
    }
    
    # Update progress bar
    setTxtProgressBar(pb = progress, value = sample)
  }
  
  # Setup output
  output <- list("posterior_samples" = 
                   list("gamma" = sample_gamma[(n_burn + 1):n_iterations, ],
                        "epsilon" = sample_epsilon[(n_burn + 1):n_iterations, ],
                        "alpha" = sample_alpha[(n_burn + 1):n_iterations, ],
                        "beta" = sample_beta[(n_burn + 1):n_iterations, ],
                        "hidden_states" = 
                          sample_states[, , , (n_burn + 1):n_iterations]),
                 "hmc_acceptance" = acc,
                 "step_size" = step_size)
  
  close(progress)
  
  return(output)
}
